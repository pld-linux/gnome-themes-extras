diff -aurN Smooth/smooth_gtk2_engine.c gtk-smooth-engine/smooth_gtk2_engine.c
--- Smooth/smooth_gtk2_engine.c	2003-11-16 20:28:02.000000000 +0100
+++ gtk-smooth-engine/smooth_gtk2_engine.c	2003-12-17 00:55:25.000000000 +0100
@@ -223,6 +223,47 @@
   smooth_draw_extension(style, window, state_type, shadow_type, area, widget, detail, x, y, width, height, gap_side);
 }
 
+static const GtkBorder default_default_border = { 1, 1, 1, 1 };
+static const GtkBorder default_default_outside_border = { 0, 0, 0, 0 };
+
+static void
+gtk_button_get_props (GtkWidget *widget,
+		      GtkBorder *default_border,
+		      GtkBorder *default_outside_border,
+		      gboolean  *interior_focus)
+{
+  GtkBorder *tmp_border;
+
+  if (default_border)
+    {
+      gtk_widget_style_get (widget, "default_border", &tmp_border, NULL);
+
+      if (tmp_border)
+	{
+	  *default_border = *tmp_border;
+	  g_free (tmp_border);
+	}
+      else
+	*default_border = default_default_border;
+    }
+
+  if (default_outside_border)
+    {
+      gtk_widget_style_get (widget, "default_outside_border", &tmp_border, NULL);
+
+      if (tmp_border)
+	{
+	  *default_outside_border = *tmp_border;
+	  g_free (tmp_border);
+	}
+      else
+	*default_outside_border = default_default_outside_border;
+    }
+
+  if (interior_focus)
+    gtk_widget_style_get (widget, "interior_focus", interior_focus, NULL);
+}
+
 static void
 draw_box(GtkStyle * style,
 	 GdkWindow * window,
@@ -239,8 +280,43 @@
   GtkOrientation orientation;
   
   g_return_if_fail(sanitize_parameters(style, window, &width, &height));
-  
-  if (DETAIL("buttondefault") || DETAIL("togglebutton") || DETAIL("button") || DETAIL("spinbutton_up") || DETAIL("spinbutton_down") || GTK_IS_BUTTON(widget))
+    
+	if (DETAIL("buttondefault"))
+	{
+		GdkRectangle button;
+
+		gint border_width = GTK_CONTAINER (widget)->border_width;
+		GtkBorder default_border;
+		GtkBorder default_outside_border;
+		gboolean interior_focus;
+		gint focus_width;
+		gint focus_pad;
+
+		gtk_button_get_props (widget, &default_border, &default_outside_border, &interior_focus);
+		gtk_widget_style_get (widget,
+					"focus-line-width", &focus_width,
+					"focus-padding", &focus_pad,
+					NULL); 
+	
+		button.x = widget->allocation.x + border_width + default_outside_border.left;
+		button.y = widget->allocation.y + border_width + default_outside_border.top;
+		button.width = (widget->allocation.width - border_width * 2) - (default_outside_border.left + default_outside_border.right);
+		button.height = (widget->allocation.height - border_width * 2) - (default_outside_border.top + default_outside_border.bottom);
+
+		if (!interior_focus)
+		{
+			button.x += focus_width + focus_pad;
+			button.y += focus_width + focus_pad;
+			button.width -= 2 * (focus_width + focus_pad);
+			button.height -= 2 * (focus_width + focus_pad);
+		}
+
+		smooth_draw_button_default(style, window, state_type, area, &button, widget, x, y, width, height);
+
+		return;
+	}	
+
+  if (DETAIL("togglebutton") || DETAIL("button") || DETAIL("spinbutton_up") || DETAIL("spinbutton_down") || GTK_IS_BUTTON(widget))
     orientation = GTK_ORIENTATION_HORIZONTAL;
   else if (DETAIL("hscrollbar"))
     orientation = GTK_ORIENTATION_HORIZONTAL;
diff -aurN Smooth/smooth_rc_style.c gtk-smooth-engine/smooth_rc_style.c
--- Smooth/smooth_rc_style.c	2003-12-14 22:00:56.000000000 +0100
+++ gtk-smooth-engine/smooth_rc_style.c	2003-12-19 22:22:13.000000000 +0100
@@ -2,6 +2,7 @@
 #include "smooth_rc_style.h"
 #include <stdio.h>
 
+/* tab part styles*/
 smooth_part_style 
 *smooth_tab_part(GtkStyle * style, gboolean for_active_tab)
 {
@@ -61,6 +62,83 @@
     return EDGE_LINE_THICKNESS(style, THEME_PART(&tabs));
 }
 
+/* button part styles*/
+smooth_part_style 
+*smooth_button_part(GtkStyle * style, gboolean for_button_default)
+{
+  smooth_button_style button = THEME_DATA(style)->button;
+  
+  if ((for_button_default) && (button.use_button_default))
+    return &THEME_DATA(style)->button.button_default;
+  else
+    return THEME_PART(&THEME_DATA(style)->button);
+}
+
+gint
+smooth_button_get_style(GtkStyle * style, gboolean for_button_default)
+{
+  smooth_button_style button = THEME_DATA(style)->button;
+  smooth_part_style button_default = THEME_DATA(style)->button.button_default;
+  
+  if ((for_button_default) && (button.use_button_default))
+    return button_default.style;
+  else
+    return THEME_PART(&button)->style;
+}
+
+gboolean
+smooth_button_default_triangle(GtkStyle * style)
+{
+  smooth_button_style button = THEME_DATA(style)->button;
+  smooth_part_style button_default = THEME_DATA(style)->button.button_default;
+  
+  if ((button.use_button_default))
+    return ((button_default.style==SMOOTH_BUTTON_DEFAULT_TRIANGLE) || (button.default_triangle));
+  else
+    return (button.default_triangle);
+}
+
+smooth_fill_style *
+smooth_button_fill(GtkStyle * style, gboolean for_button_default)
+{
+  smooth_button_style button = THEME_DATA(style)->button;
+  smooth_part_style button_default = THEME_DATA(style)->button.button_default;
+  
+  if ((for_button_default) && (button.use_button_default) && (button_default.use_fill))
+    return &THEME_DATA(style)->button.button_default.fill;
+  else
+    return &THEME_PART(&THEME_DATA(style)->button)->fill;
+}
+
+gint
+smooth_button_edge_line_style(GtkStyle * style, gboolean for_button_default)
+{
+  smooth_button_style button = THEME_DATA(style)->button;
+  smooth_part_style button_default = THEME_DATA(style)->button.button_default;
+  
+  if ((for_button_default) && (button.use_button_default) && (button_default.edge.use_line || button_default.use_line))
+    return EDGE_LINE_STYLE(style, &button_default);
+  else
+    return EDGE_LINE_STYLE(style, THEME_PART(&button));
+}
+
+gint
+smooth_button_edge_line_thickness(GtkStyle * style, gboolean for_button_default)
+{
+  smooth_button_style button = THEME_DATA(style)->button;
+  smooth_part_style button_default = THEME_DATA(style)->button.button_default;
+  
+  if ((for_button_default) && (button.use_button_default) && (button_default.edge.use_line || button_default.use_line))
+    return EDGE_LINE_THICKNESS(style, &button_default);
+  else
+    return EDGE_LINE_THICKNESS(style, THEME_PART(&button));
+}
+
+#if GTK1
+  #define GtkSettings  int
+#endif
+
+#if GTK2
 static void   smooth_rc_style_class_init (SmoothRcStyleClass *klass);
 static guint  smooth_rc_style_parse (GtkRcStyle *rc_style, GtkSettings *settings,
 					     GScanner *scanner);
@@ -70,12 +148,11 @@
 static GtkRcStyleClass *parent_rc_class;
 
 GType smooth_type_rc_style = 0;
+#endif
 
 enum
   {
-    TOKEN_GRADIENT = G_TOKEN_LAST + 1,
-
-    TOKEN_REAL_SLIDERS,
+    TOKEN_REAL_SLIDERS = G_TOKEN_LAST + 1,
     TOKEN_RESIZE_GRIP,
 
     TOKEN_STYLE,
@@ -96,6 +173,8 @@
     TOKEN_LINE,
     TOKEN_THICKNESS,
 
+    TOKEN_FOREGROUND,
+
     TOKEN_ARROW,
     TOKEN_SOLID,
     TOKEN_ETCHED,
@@ -103,7 +182,9 @@
     TOKEN_FOCUS,
     TOKEN_PATTERN,
 
-    TOKEN_FOREGROUND,
+    TOKEN_BUTTON,
+    TOKEN_BUTTON_DEFAULT,
+    TOKEN_DEFAULT_TRIANGLE,
 
     TOKEN_TABS,
     TOKEN_ACTIVE_TAB,
@@ -126,7 +207,21 @@
     TOKEN_XPADDING,
     TOKEN_YPADDING,
 
-    TOKEN_DEPRECATED_TABSTYLE,//backward compatibility for 0.5.2 & 0.5.4
+    /* backward compatibility for <= 0.5.4 */
+    TOKEN_DEPRECATED_TABSTYLE,
+
+    /* backward compatibility for <= 0.5.0 */
+    TOKEN_DEPRECATED_ARROWSTYLE,
+    TOKEN_DEPRECATED_SOLIDARROW,
+    TOKEN_DEPRECATED_ETCHEDARROW,
+    
+    /* backward compatibility for <= 0.4.0 */
+    TOKEN_DEPRECATED_GRADIENT,
+
+    #if GTK1
+    TOKEN_XTHICKNESS,
+    TOKEN_YTHICKNESS,
+    #endif
   };
   
 static struct
@@ -137,8 +232,6 @@
 
 theme_symbols[] =
 {
-  { "use_gradient",        TOKEN_GRADIENT },
-
   { "real_sliders",        TOKEN_REAL_SLIDERS },
   { "resize_grip",         TOKEN_RESIZE_GRIP },
 
@@ -160,6 +253,8 @@
   { "line",                TOKEN_LINE },
   { "thickness",           TOKEN_THICKNESS },
 
+  { "foreground",          TOKEN_FOREGROUND },
+
   { "arrow",     	   TOKEN_ARROW },
   { "solid",               TOKEN_SOLID },
   { "etched",              TOKEN_ETCHED },
@@ -167,7 +262,9 @@
   { "focus",               TOKEN_FOCUS },
   { "pattern",             TOKEN_PATTERN },
 
-  { "foreground",             TOKEN_FOREGROUND },
+  { "button",              TOKEN_BUTTON },
+  { "default",             TOKEN_BUTTON_DEFAULT },
+  { "show_triangle",       TOKEN_DEFAULT_TRIANGLE },
 
   { "tabs",                TOKEN_TABS },
   { "active_tab",          TOKEN_ACTIVE_TAB },
@@ -190,7 +287,21 @@
   { "xpadding",            TOKEN_XPADDING },
   { "ypadding",            TOKEN_YPADDING },
 
-  { "tab_style",           TOKEN_DEPRECATED_TABSTYLE },//backward compatibility for 0.5.2 & 0.5.4
+  /* backward compatibility for <= 0.5.4 */
+  { "tab_style",           TOKEN_DEPRECATED_TABSTYLE },
+
+  /* backward compatibility for <= 0.5.0 */
+  { "arrow_style",     	   TOKEN_DEPRECATED_ARROWSTYLE },
+  { "solid_arrow",         TOKEN_DEPRECATED_SOLIDARROW },
+  { "etched_arrow",        TOKEN_DEPRECATED_ETCHEDARROW },
+
+  /* backward compatibility for <= 0.4.0 */
+  { "use_gradient",        TOKEN_DEPRECATED_GRADIENT },
+
+  #if GTK1
+  { "xthickness",          TOKEN_XTHICKNESS },
+  { "ythickness",          TOKEN_YTHICKNESS },
+  #endif
 };
 
 static guint n_theme_symbols = sizeof(theme_symbols) / sizeof(theme_symbols[0]);
@@ -251,7 +362,7 @@
     *retval = SMOOTH_LINE_SMOOTHED;
   else if (is_enum("cold") || is_enum("wonderland"))
     *retval = SMOOTH_LINE_COLD;
-  else if (is_enum("win32") || is_enum("windows") || is_enum("m$") || is_enum("winblows") || is_enum("redmond"))
+  else if (is_enum("win32") || is_enum("windows") || is_enum("redmond"))
     *retval = SMOOTH_LINE_WIN32;
   else
     return FALSE; 
@@ -280,6 +391,24 @@
 }
 
 static gboolean 
+TranslateButtonDefaultStyleName (gchar * str, gint *retval)
+{
+#define is_enum(XX)  (g_ascii_strncasecmp(str, XX, strlen(XX))==0)
+  if (is_enum("gtk") || is_enum("gtk1") || is_enum("default") || is_enum("normal") || is_enum("standard"))
+    *retval = SMOOTH_BUTTON_DEFAULT_NORMAL;
+  else if (is_enum("win32") || is_enum("windows") || is_enum("redmond"))
+    *retval = SMOOTH_BUTTON_DEFAULT_WIN32;
+  else if (is_enum("triangle"))
+    *retval = SMOOTH_BUTTON_DEFAULT_TRIANGLE;
+  else if (is_enum("none"))
+    *retval = SMOOTH_BUTTON_DEFAULT_NONE;
+  else
+    return FALSE; 
+
+  return TRUE;
+}
+
+static gboolean 
 TranslateTabStyleName (gchar * str, gint *retval)
 {
 #define is_enum(XX)  (g_ascii_strncasecmp(str, XX, strlen(XX))==0)
@@ -340,7 +469,6 @@
     part->fill.use_color1[i] = FALSE;
     part->fill.use_color2[i] = FALSE;
     part->fill.file_name[i] = NULL;
-    
   }
 
   part->edge.use_line        = FALSE;
@@ -387,6 +515,21 @@
     style->colors.has_midlight[i] = FALSE;
   }
 
+#ifdef GTK1
+  style->focus.interior = FALSE;
+  style->focus.width = 1;
+  style->focus.pad = 0;
+
+  style->range.slider_width = 7;
+  style->range.trough_border = 1;
+  style->range.stepper_size = 11;
+  style->range.stepper_spacing = 1;
+
+  style->scale.slider_length = 7;
+
+  style->scrollbar.min_slider_length = 13;
+#endif
+
   style->arrow.style     = DEFAULT_ARROWSTYLE;
   style->arrow.solid     = DEFAULT_SOLIDARROW;
   style->arrow.etched    = DEFAULT_ETCHEDARROW;
@@ -409,9 +552,22 @@
   part_init(style, THEME_PART(&style->trough), 0);
   style->trough.show_value = DEFAULT_TROUGH_SHOW_VALUE;
   
+  part_init(style, THEME_PART(&style->button), 0);
+  part_init(style, &style->button.button_default, DEFAULT_BUTTONDEFAULTSTYLE);
+  style->button.default_triangle = DEFAULT_BUTTONDEFAULTTRIANGLE;
+  style->button.use_button_default = FALSE;
+  
   part_init(style, THEME_PART(&style->tabs), DEFAULT_TABSTYLE);
   part_init(style, &style->tabs.active_tab, DEFAULT_TABSTYLE);
   style->tabs.use_active_tab	= FALSE;
+
+  #if GTK1
+  style->xthickness       = -1;
+  style->ythickness       = -1;
+
+  style->paned_handle_size	  = 10;
+  style->buffered_fill = FALSE;
+  #endif
 }
 
 static guint 
@@ -691,7 +847,12 @@
 
         token = g_scanner_get_next_token (scanner);
         if (token == G_TOKEN_STRING)
+#ifdef GTK1
+          retval->file_name[state] = gtk_rc_find_pixmap_in_path(scanner, scanner->value.v_string);
+#endif
+#ifdef GTK2
           retval->file_name[state] = gtk_rc_find_pixmap_in_path(settings, scanner, scanner->value.v_string);
+#endif
       }	
       break;
     case TOKEN_QUADRATIC_GRADIENT:
@@ -882,6 +1043,125 @@
   return token;
 }
 
+static guint theme_parse_button_default (GtkSettings  *settings, GScanner *scanner, GTokenType wanted_token, smooth_part_style *retval)
+{
+  guint token;
+
+  token = g_scanner_get_next_token (scanner);
+  if (token != wanted_token)
+    {
+      return wanted_token;
+    }
+
+  token = g_scanner_get_next_token (scanner);
+  if (token != G_TOKEN_LEFT_CURLY)
+    return G_TOKEN_LEFT_CURLY;
+
+  token = g_scanner_peek_next_token (scanner);
+  while (token != G_TOKEN_RIGHT_CURLY) {
+    switch (token) {
+      case TOKEN_STYLE:
+	token = theme_parse_custom_enum(scanner, TOKEN_STYLE, TranslateButtonDefaultStyleName, DEFAULT_BUTTONDEFAULTSTYLE, &THEME_PART(retval)->style);
+	break;
+	
+      case TOKEN_LINE:
+        token = theme_parse_line (settings, scanner, TOKEN_LINE, &THEME_PART(retval)->line);
+        THEME_PART(retval)->use_line = TRUE;
+        break;
+
+      case TOKEN_FILL :
+        token = theme_parse_fill (settings, scanner, TOKEN_FILL, &THEME_PART(retval)->fill);
+        THEME_PART(retval)->use_fill = TRUE;
+        break;
+  
+      case TOKEN_EDGE:
+        token = theme_parse_edge (settings, scanner, TOKEN_EDGE, &THEME_PART(retval)->edge);
+        break;
+
+      case TOKEN_XPADDING:
+        token = theme_parse_int (scanner, TOKEN_XPADDING, 0, &THEME_PART(retval)->xpadding, -25, 25);
+        break;
+
+      case TOKEN_YPADDING:
+        token = theme_parse_int (scanner, TOKEN_YPADDING, 0, &THEME_PART(retval)->ypadding, -25, 25);
+        break;
+    default:
+      g_scanner_get_next_token (scanner);
+      token = G_TOKEN_RIGHT_CURLY;
+      break;
+    }
+
+    token = g_scanner_peek_next_token (scanner);
+  }
+
+  g_scanner_get_next_token (scanner);
+  token = G_TOKEN_NONE;
+
+  return token;
+}
+
+static guint theme_parse_button (GtkSettings  *settings, GScanner *scanner, GTokenType wanted_token, smooth_button_style *retval)
+{
+  guint token;
+
+  token = g_scanner_get_next_token (scanner);
+  if (token != wanted_token)
+    {
+      return wanted_token;
+    }
+
+  token = g_scanner_get_next_token (scanner);
+  if (token != G_TOKEN_LEFT_CURLY)
+    return G_TOKEN_LEFT_CURLY;
+
+  token = g_scanner_peek_next_token (scanner);
+  while (token != G_TOKEN_RIGHT_CURLY) {
+    switch (token) {
+      case TOKEN_BUTTON_DEFAULT:
+	token = theme_parse_button_default (settings, scanner, TOKEN_BUTTON_DEFAULT, &retval->button_default);
+	retval->use_button_default = TRUE;
+	break;	  
+
+      case TOKEN_DEFAULT_TRIANGLE:
+	token = theme_parse_boolean (scanner, TOKEN_DEFAULT_TRIANGLE, DEFAULT_BUTTONDEFAULTTRIANGLE,  &retval->default_triangle);
+	break;	  
+
+      case TOKEN_LINE:
+        token = theme_parse_line (settings, scanner, TOKEN_LINE, &THEME_PART(retval)->line);
+        THEME_PART(retval)->use_line = TRUE;
+        break;
+
+      case TOKEN_FILL :
+        token = theme_parse_fill (settings, scanner, TOKEN_FILL, &THEME_PART(retval)->fill);
+        THEME_PART(retval)->use_fill = TRUE;
+        break;
+
+      case TOKEN_EDGE:
+        token = theme_parse_edge (settings, scanner, TOKEN_EDGE, &THEME_PART(retval)->edge);
+        break;
+
+      case TOKEN_XPADDING:
+        token = theme_parse_int (scanner, TOKEN_XPADDING, 0, &THEME_PART(retval)->xpadding, -25, 25);
+        break;
+
+      case TOKEN_YPADDING:
+        token = theme_parse_int (scanner, TOKEN_YPADDING, 0, &THEME_PART(retval)->ypadding, -25, 25);
+        break;
+    default:
+      g_scanner_get_next_token (scanner);
+      token = G_TOKEN_RIGHT_CURLY;
+      break;
+    }
+
+    token = g_scanner_peek_next_token (scanner);
+  }
+
+  g_scanner_get_next_token (scanner);
+  token = G_TOKEN_NONE;
+
+  return token;
+}
+
 static guint theme_parse_active_tab (GtkSettings  *settings, GScanner *scanner, GTokenType wanted_token, smooth_part_style *retval)
 {
   guint token;
@@ -974,7 +1254,7 @@
         token = theme_parse_fill (settings, scanner, TOKEN_FILL, &THEME_PART(retval)->fill);
         THEME_PART(retval)->use_fill = TRUE;
         break;
-  
+
       case TOKEN_EDGE:
         token = theme_parse_edge (settings, scanner, TOKEN_EDGE, &THEME_PART(retval)->edge);
         break;
@@ -1270,10 +1550,174 @@
   return token;
 }
 
+#if GTK1
+static void
+smooth_gtk1_style_overides(SmoothRcStyle *smooth_style, SmoothRcProperty * smooth_prop)
+{		       
+  #define is_class(xx) ((xx) && (!strcmp(xx, smooth_prop->class_name)))
+  #define is_prop(xx) ((xx) && (!strcmp(xx, smooth_prop->property_name)))
+
+  if (is_class("GtkRange"))
+  {
+    GtkRangeClass *rangeclass = (GtkRangeClass *)gtk_type_class(gtk_range_get_type());
+    if (is_prop("slider-width") || is_prop("slider_width")) 
+        smooth_style->range.slider_width = smooth_prop->value.d.long_data;
+    if (is_prop("stepper_size") || is_prop("stepper-size")) 
+        smooth_style->range.stepper_size = smooth_prop->value.d.long_data;
+    if (is_prop("stepper_spacing") || is_prop("stepper-spacing")) 
+        smooth_style->range.stepper_spacing = smooth_prop->value.d.long_data;
+  } 
+  else
+    if (is_class("GtkPaned"))
+    {
+      if (is_prop("handle-size") || is_prop("handle_size")) 
+        smooth_style->paned_handle_size = smooth_prop->value.d.long_data;
+    }
+  else
+    if (is_class("GtkScrollbar"))
+    {
+      if (is_prop("min_slider_length") || is_prop("min-slider-length")) 
+        smooth_style->scrollbar.min_slider_length = smooth_prop->value.d.long_data;
+    }
+  else
+    if (is_class("GtkScale"))
+    {
+      GtkScaleClass *scaleclass = gtk_type_class(gtk_scale_get_type());
+      GtkRangeClass *rangeclass = (GtkRangeClass *)scaleclass;
+      if (is_prop("slider_width") || is_prop("slider-width")) 
+        rangeclass->slider_width = smooth_prop->value.d.long_data;
+      if (is_prop("slider_length") || is_prop("slider-length")) 
+        smooth_style->scale.slider_length = smooth_prop->value.d.long_data;
+    }
+  else
+    if (is_class("GtkCheckButton"))
+    {
+      GtkCheckButtonClass *checkbuttonclass = (GtkCheckButtonClass*)gtk_type_class (gtk_check_button_get_type ());
+  
+      if (is_prop("indicator_size") || is_prop("indicator-size")) 
+        checkbuttonclass->indicator_size = smooth_prop->value.d.long_data;
+    }
+  else
+    if (is_class("GtkRadioButton"))
+    {
+      GtkCheckButtonClass *checkbuttonclass = (GtkCheckButtonClass*)gtk_type_class (gtk_radio_button_get_type ());
+
+      if (is_prop("indicator_size") || is_prop("indicator-size"))  
+        checkbuttonclass->indicator_size = smooth_prop->value.d.long_data;
+    }
+  else 
+    if (is_class("GtkWidget"))
+    {
+      if (is_prop("interior_focus") || is_prop("interior-focus"))  
+        smooth_style->focus.interior = smooth_prop->value.d.long_data;
+
+      if (is_prop("focus_line_width") || is_prop("focus-line-width"))  
+        smooth_style->focus.width = smooth_prop->value.d.long_data;
+
+      if (is_prop("focus_padding ") || is_prop("focus-padding"))  
+        smooth_style->focus.pad = smooth_prop->value.d.long_data;
+    }
+
+   
+}
+
+static guint
+gtk_rc_parse_assignment (GScanner      *scanner,
+			 SmoothRcProperty *prop)
+{
+  gboolean scan_identifier = scanner->config->scan_identifier;
+  gboolean scan_symbols = scanner->config->scan_symbols;
+  gboolean identifier_2_string = scanner->config->identifier_2_string;
+  gboolean char_2_token = scanner->config->char_2_token;
+  gboolean scan_identifier_NULL = scanner->config->scan_identifier_NULL;
+  gboolean numbers_2_int = scanner->config->numbers_2_int;
+  gboolean negate = FALSE;
+  guint token;
+
+  /* check that this is an assignment */
+  if (g_scanner_get_next_token (scanner) != '=')
+    return '=';
+
+  /* adjust scanner mode */
+  scanner->config->scan_identifier = TRUE;
+  scanner->config->scan_symbols = FALSE;
+  scanner->config->identifier_2_string = FALSE;
+  scanner->config->char_2_token = TRUE;
+  scanner->config->scan_identifier_NULL = FALSE;
+  scanner->config->numbers_2_int = TRUE;
+
+  /* parse optional sign */
+  if (g_scanner_peek_next_token (scanner) == '-')
+    {
+      g_scanner_get_next_token (scanner); /* eat sign */
+      negate = TRUE;
+    }
+
+  /* parse one of LONG, DOUBLE and STRING or, if that fails, create an unparsed compund */
+  token = g_scanner_peek_next_token (scanner);
+  switch (token)
+    {
+    case G_TOKEN_INT:
+      g_scanner_get_next_token (scanner);
+      prop->value.type = GTK_TYPE_LONG;
+      prop->value.d.long_data = negate ? -scanner->value.v_int : scanner->value.v_int;
+      token = G_TOKEN_NONE;
+      break;
+    case G_TOKEN_FLOAT:
+      g_scanner_get_next_token (scanner);
+      prop->value.type = GTK_TYPE_DOUBLE;
+      prop->value.d.double_data = negate ? -scanner->value.v_float : scanner->value.v_float;
+      token = G_TOKEN_NONE;
+      break;
+    case G_TOKEN_STRING:
+      g_scanner_get_next_token (scanner);
+      if (negate)
+	token = G_TOKEN_INT;
+      else
+	{
+          prop->value.type = GTK_TYPE_STRING;
+          prop->value.d.string_data = scanner->value.v_string;
+	  token = G_TOKEN_NONE;
+	}
+      break;
+    case G_TOKEN_LEFT_CURLY :
+      while (token != G_TOKEN_RIGHT_CURLY) {
+        g_scanner_peek_next_token (scanner);   
+        g_scanner_get_next_token (scanner);
+        token = g_scanner_peek_next_token (scanner);
+      } 
+      g_scanner_get_next_token (scanner);
+      token = G_TOKEN_NONE;      
+      break;      
+    default:
+      g_scanner_get_next_token (scanner);
+      token = G_TOKEN_INT;
+      break;
+    }
+
+  /* restore scanner mode */
+  scanner->config->scan_identifier = scan_identifier;
+  scanner->config->scan_symbols = scan_symbols;
+  scanner->config->identifier_2_string = identifier_2_string;
+  scanner->config->char_2_token = char_2_token;
+  scanner->config->scan_identifier_NULL = scan_identifier_NULL;
+  scanner->config->numbers_2_int = numbers_2_int;
+
+  return token;
+}
+#endif
+
+#if GTK2
 static guint 
 smooth_rc_style_parse (GtkRcStyle *rc_style,
                        GtkSettings  *settings,
 		       GScanner   *scanner)
+#endif
+#if GTK1
+guint 
+smooth_rc_style_parse (GScanner * scanner, 
+                       GtkRcStyle * rc_style)
+#endif
 {
   static GQuark scope_id = 0;
   SmoothRcStyle *smooth_style = NEW_THEME_DATA(rc_style);
@@ -1282,6 +1726,13 @@
   guint token;
   guint i;
 
+  #if GTK1
+    GtkSettings  *settings=NULL; 
+  
+  smooth_style->refcount = 1;
+  smooth_rc_style_init (smooth_style);
+  #endif
+
   /* Set up a new scope in this scanner */
   if (!scope_id)
     {
@@ -1295,11 +1746,17 @@
   /* Check if we already added our symbols to this scope */
   if (!g_scanner_lookup_symbol (scanner, theme_symbols[0].name))
     {
+      #ifdef GTK1
+        g_scanner_freeze_symbol_table (scanner);
+      #endif 	
       for (i = 0; i < n_theme_symbols; i++)
 	{
 	  g_scanner_scope_add_symbol (scanner, scope_id, theme_symbols[i].name, 
 				      GINT_TO_POINTER (theme_symbols[i].token));
 	}
+      #ifdef GTK1
+        g_scanner_thaw_symbol_table (scanner);
+      #endif 	
     }
 
   /* Read to go, now parse the top level */
@@ -1317,6 +1774,9 @@
         case TOKEN_TABS:
           token = theme_parse_tab (settings, scanner, TOKEN_TABS, &smooth_style->tabs);
           break;
+        case TOKEN_BUTTON:
+          token = theme_parse_button (settings, scanner, TOKEN_BUTTON, &smooth_style->button);
+          break;
 	case TOKEN_REAL_SLIDERS:
 	  token = theme_parse_boolean (scanner, TOKEN_REAL_SLIDERS, DEFAULT_REAL_SLIDERS, &smooth_style->real_sliders);
 	  break;
@@ -1347,10 +1807,80 @@
 	case TOKEN_OPTION:
 	  token = theme_parse_option (settings, scanner, TOKEN_OPTION, &smooth_style->option);
 	  break;
+
+        /* backward compatibility for <=0.5.4 */
 	case TOKEN_DEPRECATED_TABSTYLE:
 	  token = theme_parse_custom_enum(scanner, TOKEN_DEPRECATED_TABSTYLE, TranslateTabStyleName, DEFAULT_TABSTYLE, 
 						&THEME_PART(&smooth_style->tabs)->style);
 	  break;
+
+        /* backward compatibility for <=0.5.0 */
+	case TOKEN_DEPRECATED_ARROWSTYLE:
+	  token = theme_parse_custom_enum(scanner, TOKEN_DEPRECATED_ARROWSTYLE, TranslateArrowStyleName, DEFAULT_ARROWSTYLE, 
+						&THEME_PART(&smooth_style->arrow)->style);
+	  break;
+
+	case TOKEN_DEPRECATED_SOLIDARROW:
+	  token = theme_parse_boolean (scanner, TOKEN_DEPRECATED_SOLIDARROW, DEFAULT_SOLIDARROW, &smooth_style->arrow.solid);
+
+	  break;
+
+	case TOKEN_DEPRECATED_ETCHEDARROW:
+	  token = theme_parse_boolean (scanner, TOKEN_DEPRECATED_ETCHEDARROW, DEFAULT_ETCHEDARROW, &smooth_style->arrow.etched);
+	  break;
+
+        /* backward compatibility for <=0.4.0 */
+	case TOKEN_DEPRECATED_GRADIENT:
+	  {
+	    gboolean use_gradient=FALSE;
+	
+	    token = theme_parse_boolean (scanner, TOKEN_DEPRECATED_GRADIENT, TRUE, &use_gradient);
+	    
+	    if (use_gradient) 
+	    {
+	      smooth_style->fill.style = SMOOTH_FILL_SHADE_GRADIENT;
+	      smooth_style->fill.quadratic_gradient = TRUE;
+	      smooth_style->fill.gradient_direction[0] = GDK_GRADIENT_VERTICAL;			
+	      smooth_style->fill.gradient_direction[1] = GDK_GRADIENT_HORIZONTAL;			
+	      smooth_style->fill.shade1 = 1.3;
+	      smooth_style->fill.shade2 = 0.7;
+	    }
+	  }  
+	  break;
+
+	#if GTK1
+	case TOKEN_XTHICKNESS:
+          token = theme_parse_int (scanner, TOKEN_XTHICKNESS, 2, &smooth_style->xthickness, 0, 100);
+	  break;	  
+	case TOKEN_YTHICKNESS:
+          token = theme_parse_int (scanner, TOKEN_YTHICKNESS, 2, &smooth_style->ythickness, 0, 100);
+	  break;	  
+	case G_TOKEN_IDENTIFIER:
+	    {
+	      SmoothRcProperty prop = {NULL, NULL, {1, NULL,}};
+	      
+	      g_scanner_get_next_token (scanner); /* eat type name */
+	      
+	      prop.class_name = g_strdup(scanner->value.v_identifier);
+	      
+	      if (g_scanner_get_next_token (scanner) != ':' ||
+		  g_scanner_get_next_token (scanner) != ':')
+		{
+		  token = ':';
+		  break;
+		}
+	      
+	      g_scanner_get_next_token (scanner);
+
+	      prop.property_name = g_strdup(scanner->value.v_identifier);
+	      token = gtk_rc_parse_assignment (scanner, &prop);
+	      if (token == G_TOKEN_NONE)
+		  smooth_gtk1_style_overides(smooth_style, &prop);
+      	      if (prop.class_name) g_free(prop.class_name);
+      	      if (prop.property_name) g_free(prop.property_name);
+	    }
+	  break;
+	#endif  
 	default:
 	  g_scanner_get_next_token (scanner);
 	  token = G_TOKEN_RIGHT_CURLY;
@@ -1375,7 +1905,7 @@
   return G_TOKEN_NONE;
 }
 	
- void part_merge (smooth_part_style *dest_part, smooth_part_style *src_part)
+void part_merge (smooth_part_style *dest_part, smooth_part_style *src_part)
 {
   gint i;
   
@@ -1418,20 +1948,38 @@
   dest_part->ypadding  	     = src_part->ypadding;
 }
 
+#if GTK2
 static void
 smooth_rc_style_merge (GtkRcStyle * dest,
                        GtkRcStyle * src)
+#endif
+#if GTK1
+void
+smooth_rc_style_merge (GtkRcStyle * dest,
+                       GtkRcStyle * src)
+#endif
 {
   gint i;
+  #if GTK2
   parent_rc_class->merge (dest, src);
+  #endif
   
+  #if GTK2
   if (SMOOTH_IS_RC_STYLE (src)) 
+  #endif
     {     
       SmoothRcStyle *src_data = SMOOTH_RC_DATA (src);
       SmoothRcStyle *dest_data = SMOOTH_RC_DATA (dest);
 
       if (!dest_data) {
         dest_data = NEW_THEME_DATA(dest);
+        #if GTK1
+        dest_data->xthickness       = src_data->xthickness;
+        dest_data->ythickness       = src_data->ythickness;
+        dest_data->paned_handle_size = src_data->paned_handle_size;
+
+	dest_data->refcount         = 1;
+        #endif
       } 	
       
       dest_data->real_sliders = src_data->real_sliders;
@@ -1484,7 +2032,7 @@
 
           dest_data->fill.file_name[i] = g_strdup(src_data->fill.file_name[i]);
         }
-
+        
         if (src_data->focus.pattern[i]) {
           if (dest_data->focus.pattern[i])
             g_free(dest_data->focus.pattern[i]);
@@ -1498,6 +2046,21 @@
 
       }
 
+#ifdef GTK1
+      dest_data->focus.interior = src_data->focus.interior;
+      dest_data->focus.width = src_data->focus.width;
+      dest_data->focus.pad = src_data->focus.pad;
+
+      dest_data->range.slider_width = src_data->range.slider_width;
+      dest_data->range.trough_border = src_data->range.trough_border;
+      dest_data->range.stepper_size = src_data->range.stepper_size;
+      dest_data->range.stepper_spacing = src_data->range.stepper_spacing;
+
+      dest_data->scale.slider_length = src_data->scale.slider_length;
+
+      dest_data->scrollbar.min_slider_length = src_data->scrollbar.min_slider_length;
+#endif
+
       dest_data->arrow.style = src_data->arrow.style;
       dest_data->arrow.solid = src_data->arrow.solid;
       dest_data->arrow.etched = src_data->arrow.etched;
@@ -1518,7 +2081,12 @@
       part_merge(THEME_PART(&dest_data->trough),THEME_PART(&src_data->trough));
       dest_data->trough.show_value = src_data->trough.show_value;
       
-      part_merge(THEME_PART(&dest_data->progress),THEME_PART(&src_data->progress));
+      part_merge(&dest_data->progress,&src_data->progress);
+
+      part_merge(THEME_PART(&dest_data->button), THEME_PART(&src_data->button));
+      dest_data->button.default_triangle = src_data->button.default_triangle;
+      dest_data->button.use_button_default = src_data->button.use_button_default;
+      part_merge(&dest_data->button.button_default,&src_data->button.button_default);
 
       part_merge(THEME_PART(&dest_data->tabs), THEME_PART(&src_data->tabs));
       dest_data->tabs.use_active_tab = src_data->tabs.use_active_tab;
@@ -1530,6 +2098,7 @@
     }
 }
 
+#if GTK2
 void part_finalize (smooth_part_style *part)
 {
   gint i;
@@ -1560,6 +2129,8 @@
         part_finalize(THEME_PART(&data->option));
         part_finalize(THEME_PART(&data->trough));
         part_finalize(&data->progress);
+        part_finalize(THEME_PART(&data->button));
+        part_finalize(&data->button.button_default);
         part_finalize(THEME_PART(&data->tabs));
         part_finalize(&data->tabs.active_tab);
       }
@@ -1610,3 +2181,4 @@
 							      "SmoothRcStyle",
 							      &object_info, 0);
 }
+#endif
diff -aurN Smooth/smooth_rc_style.h gtk-smooth-engine/smooth_rc_style.h
--- Smooth/smooth_rc_style.h	2003-11-16 20:28:32.000000000 +0100
+++ gtk-smooth-engine/smooth_rc_style.h	2003-12-17 00:55:25.000000000 +0100
@@ -17,11 +17,25 @@
 #define SMOOTH_FILL_SHADE_GRADIENT	3
 #define SMOOTH_FILL_PIXBUF		4
 
+#define SMOOTH_FONT_NORMAL		1
+#define SMOOTH_FONT_BOLD		2
+#define SMOOTH_FONT_ITALIC		3
+#define SMOOTH_FONT_BOLD_ITALIC		4
+
+#define SMOOTH_TEXT_INHERITED		1
+#define SMOOTH_TEXT_DEFAULT		2
+#define SMOOTH_TEXT_CUSTOM		3
+
 #define SMOOTH_EDGE_NONE		1
 #define SMOOTH_EDGE_LINE		2
 #define SMOOTH_EDGE_GRADIENT		3
 #define SMOOTH_EDGE_PIXBUF		4
 
+#define SMOOTH_BUTTON_DEFAULT_NONE	1
+#define SMOOTH_BUTTON_DEFAULT_NORMAL	2
+#define SMOOTH_BUTTON_DEFAULT_WIN32	3
+#define SMOOTH_BUTTON_DEFAULT_TRIANGLE	4
+
 #define SMOOTH_TAB_NORMAL		1
 #define SMOOTH_TAB_ROUND		2
 #define SMOOTH_TAB_TRIANGLE		3
@@ -35,6 +49,8 @@
 #define DEFAULT_EDGESTYLE		LINE_EDGE
 #define DEFAULT_LINETHICKNESS		2
 #define DEFAULT_LINESTYLE		SMOOTH_LINE_STANDARD
+#define DEFAULT_BUTTONDEFAULTSTYLE	SMOOTH_BUTTON_DEFAULT_NORMAL
+#define DEFAULT_BUTTONDEFAULTTRIANGLE	TRUE
 #define DEFAULT_TABSTYLE		SMOOTH_TAB_NORMAL
 #define DEFAULT_GRIPSTYLE		FIXEDLINES_IN_GRIP
 #define DEFAULT_ARROWSTYLE		ARROW_STYLE_THINICE
@@ -48,9 +64,16 @@
 #define DEFAULT_TROUGH_SHOW_VALUE	FALSE
 #define DEFAULT_GRIPOVERLAP		FALSE
 
+
 typedef struct _SmoothRcStyle SmoothRcStyle;
 
+#if GTK1
+typedef struct _SmoothRcProperty SmoothRcProperty;
+#endif
+
+#if GTK2
 typedef struct _SmoothRcStyleClass SmoothRcStyleClass;
+#endif
 
 typedef struct _smooth_line_style smooth_line_style;
 typedef struct _smooth_fill_style smooth_fill_style;
@@ -66,6 +89,7 @@
 typedef struct _smooth_check_style smooth_check_style;
 typedef struct _smooth_option_style smooth_option_style;
 typedef struct _smooth_arrow_style smooth_arrow_style;
+typedef struct _smooth_button_style smooth_button_style;
 typedef struct _smooth_tab_style smooth_tab_style;
 typedef struct _smooth_trough_style smooth_trough_style;
 
@@ -73,6 +97,7 @@
 
 #define THEME_PART(part)                 ((smooth_part_style *) (part))
 
+#if GTK2
 extern GType smooth_type_rc_style;
 
 #define SMOOTH_TYPE_RC_STYLE              smooth_type_rc_style
@@ -86,6 +111,17 @@
 #define THEME_DATA(style)                 (SMOOTH_RC_STYLE (style->rc_style))
 #define NEW_THEME_DATA(rc_style)          (SMOOTH_RC_STYLE (rc_style))
 #define SET_THEME_DATA(rc_style, data)    (SMOOTH_RC_DATA (rc_style))
+#endif
+
+#if GTK1
+#define SMOOTH_RC_DATA(rc_style)          ((SmoothRcStyle *) ((rc_style)->engine_data))
+
+#define THEME_DATA(style)                 ((SmoothRcStyle *) (((GtkStyle *)style)->engine_data))
+#define NEW_THEME_DATA(rc_style)          ((SmoothRcStyle *) (g_new0 (SmoothRcStyle, 1)))
+#define SET_THEME_DATA(rc_style, data)    (rc_style->engine_data=data)
+
+#define PANED_HANDLE_SIZE(style)(THEME_DATA(style)->paned_handle_size)
+#endif
 
 #define REAL_SLIDERS(style)(THEME_DATA(style)->real_sliders)
 #define RESIZE_GRIP(style)(THEME_DATA(style)->resize_grip)
@@ -135,12 +171,29 @@
 #define ARROW_XPADDING(part)(THEME_DATA(style)->arrow.ypadding)
 #define ARROW_YPADDING(part)(THEME_DATA(style)->arrow.xpadding)
 
+#ifdef GTK1
+#define FOCUS_INTERIOR(style)(THEME_DATA(style)->focus.interior)
+#define FOCUS_WIDTH(style)(THEME_DATA(style)->focus.width)
+#define FOCUS_PAD(style)(THEME_DATA(style)->focus.pad)
+#endif
+
 #define FOCUS_USE_FOREGROUND(style, state)(THEME_DATA(style)->focus.use_foreground[state])
 #define FOCUS_FOREGROUND(style, state)(THEME_DATA(style)->focus.foreground[state])
 
 #define FOCUS_USE_PATTERN(style, state)(THEME_DATA(style)->focus.pattern[state]!=NULL)
 #define FOCUS_PATTERN(style, state)(THEME_DATA(style)->focus.pattern[state])
 
+#ifdef GTK1
+  #define RANGE_SLIDER_WIDTH(style)(THEME_DATA(style)->range.slider_width)
+  #define RANGE_TROUGH_BORDER(style)(THEME_DATA(style)->range.trough_border)
+  #define RANGE_STEPPER_SIZE(style)(THEME_DATA(style)->range.stepper_size)
+  #define RANGE_STEPPER_SPACING(style)(THEME_DATA(style)->range.stepper_spacing)
+  
+  #define SCALE_SLIDER_LENGTH(style)(THEME_DATA(style)->scale.slider_length)
+
+  #define SCROLLBAR_MIN_SLIDER_LENGTH(style)(THEME_DATA(style)->scrollbar.min_slider_length)
+#endif
+
 #define BUFFERED_FILL(style)(THEME_DATA(style)->buffered_fill)
 
 struct _smooth_line_style {
@@ -237,6 +290,19 @@
 
   gint xpadding;
   gint ypadding;
+
+  /*smooth_part_style part;
+  gint border;
+  gint fill;*/
+};
+
+struct _smooth_button_style {
+  smooth_part_style part;
+  gboolean default_triangle;
+
+  gboolean use_button_default;
+
+  smooth_part_style button_default;
 };
 
 struct _smooth_tab_style {
@@ -254,7 +320,13 @@
 
 struct _SmoothRcStyle
 {
+  #if GTK2
   GtkRcStyle parent_instance;
+  #endif
+
+  #if GTK1
+  gint			  refcount;
+  #endif
   
   gboolean buffered_fill;
   
@@ -295,19 +367,61 @@
   smooth_check_style	  check;
   smooth_option_style	  option;
   smooth_arrow_style      arrow;
+  smooth_button_style	  button;
   smooth_tab_style	  tabs;
 
+  #if GTK1
+  struct {
+    gint slider_width;
+    gint trough_border;
+    gint stepper_size;
+    gint stepper_spacing;
+  } range;
+
+  struct {
+    gint slider_length;
+  } scale;
+
+  struct {
+    gint min_slider_length;
+  } scrollbar;
+
+  gint			  xthickness;
+  gint			  ythickness;
+
+  guint16		  paned_handle_size;
+  #endif
 };
 
 void smooth_rc_style_init (SmoothRcStyle *style);
 
+#if GTK2
 struct _SmoothRcStyleClass
 {
   GtkRcStyleClass parent_class;
 };
 
 void smooth_rc_style_register_type (GTypeModule *module);
+#endif
+
+#if GTK1
+void
+smooth_rc_style_merge (GtkRcStyle * dest,
+                       GtkRcStyle * src);
+		       
+guint 
+smooth_rc_style_parse (GScanner * scanner, 
+                       GtkRcStyle * rc_style);
+
+struct _SmoothRcProperty
+{
+  gchar * class_name;
+  gchar * property_name;
+  GtkArg value;
+};
+#endif
 
+/* tab part styles*/
 smooth_part_style *smooth_tab_part(GtkStyle * style, gboolean for_active_tab);
 
 gint smooth_tab_get_style(GtkStyle * style, gboolean for_active_tab);
@@ -316,3 +430,15 @@
 
 gint smooth_tab_edge_line_style(GtkStyle * style, gboolean for_active_tab);
 gint smooth_tab_edge_line_thickness(GtkStyle * style, gboolean for_active_tab);
+
+/* button part styles*/
+smooth_part_style *smooth_button_part(GtkStyle * style, gboolean for_default_button);
+
+gint smooth_button_get_style(GtkStyle * style, gboolean for_default_button);
+
+gboolean smooth_button_default_triangle(GtkStyle * style);
+
+smooth_fill_style *smooth_button_fill(GtkStyle * style, gboolean for_default_button);
+
+gint smooth_button_edge_line_style(GtkStyle * style, gboolean for_default_button);
+gint smooth_button_edge_line_thickness(GtkStyle * style, gboolean for_default_button);
diff -aurN Smooth/smooth_style.c gtk-smooth-engine/smooth_style.c
--- Smooth/smooth_style.c	2003-12-14 22:00:56.000000000 +0100
+++ gtk-smooth-engine/smooth_style.c	2003-12-19 22:22:13.000000000 +0100
@@ -210,7 +210,6 @@
     gdk_bitmap_unref(clip_mask);
 }
 
-
 void
 smooth_draw_shadow_with_gap(GtkStyle * style,
                             GdkWindow * window,
@@ -236,13 +235,6 @@
   GdkGC              *dark, *light, *mid, *middark=NULL, *midlight=NULL;
   gboolean 	     line_overlap = FALSE;
 
-  if ((EDGE_LINE_STYLE(style, part)==SMOOTH_LINE_WIN32) && DETAIL("buttondefault")) {
-    shade = shaded_color (style, state_type, shades[8]);
-    do_draw_shadow_with_gap(window, area, shade, shade, x, y, width, height, gap_side, gap_pos, gap_size, TRUE);
-    if (shade) gtk_gc_release (shade);
-    return;
-  }
-  
   if (EDGE_LINE_STYLE(style, part)==SMOOTH_LINE_NONE) return;
   
   if (shadow_type == GTK_SHADOW_NONE) return;
@@ -674,10 +666,21 @@
          x = x + (width - w)/2;
        }
 
+       #if GTK1
+       x += 1 + (gint)(ns);
+       y += 1 + (gint)(ns);
+       width = w - 3;
+       height = h - 3;
+//       g_warning("GTK1.2 SPECIFIC CODE STILL IN smooth_draw_slider_grip!!!");
+       #endif
+
+       #if GTK2
        x += 2 + (gint)(ns);
        y += 3 + (gint)(ns);
        width = w - 4;
        height = h - 6;
+//       g_warning("GTK2 SPECIFIC CODE STILL IN smooth_draw_slider_grip!!!");
+       #endif
       
         /* too small no buds */
        if ((width <= 13) && (height <= 11))
@@ -707,7 +710,7 @@
 {
   g_return_if_fail(sanitize_parameters(style, window, &width, &height));
 
-  if ((EDGE_LINE_STYLE(style,NULL) == SMOOTH_LINE_FLAT)  && DETAIL ("entry") && widget && (GTK_IS_SPIN_BUTTON (widget) || (widget->parent && GTK_IS_COMBO(widget->parent)))) 
+  if ((EDGE_LINE_STYLE(style,NULL) == SMOOTH_LINE_FLAT)  && DETAIL ("entry") && widget && (GTK_IS_SPIN_BUTTON (widget) || (widget->parent && GTK_IS_COMBO_BOX(widget->parent)))) 
   {
        gtk_paint_flat_box(style, window, widget->state, GTK_SHADOW_NONE, area, widget, "entry_bg", x, y, width, height);
 
@@ -1127,6 +1130,76 @@
 }
 
 void
+smooth_draw_button_default(GtkStyle *style,
+                           GdkWindow *window,
+                           GtkStateType state_type,
+                           GdkRectangle *clip,
+                           GdkRectangle *button,
+                           GtkWidget *widget,
+                           gint x,
+                           gint y,
+                           gint width,
+                           gint height)
+{
+	GdkRectangle button_area;
+	smooth_part_style *button_default=smooth_button_part(style, TRUE);
+	
+	if (button)
+	{
+		button_area.x = button->x;
+		button_area.y = button->y;
+		button_area.width = button->width;
+		button_area.height = button->height;
+	}
+	else
+	{
+		//if no button area was passed assume the button area is 1 pixel inside, eg. assume there is room for win32 focus
+		button_area.x = x+1;
+		button_area.y = y+1;
+		button_area.width = width+1;
+		button_area.height = height+1;
+	}
+	
+	switch (smooth_button_get_style(style, TRUE))
+	{
+		case SMOOTH_BUTTON_DEFAULT_NORMAL:
+		{
+			/*paint fill with a gradient, invert if GTK_SHADOW_IN */
+			gradient_fill_background(style, window, GTK_SHADOW_IN, clip, widget, button_default, x, y, width, height, TRUE, GTK_ORIENTATION_VERTICAL);
+
+			/* paint shadow */
+			smooth_draw_shadow_with_gap(style, window, state_type, GTK_SHADOW_IN, clip, widget, "button", button_default, x, y, width, height, 0, 0, 0);     
+		}	
+		break;
+
+		case SMOOTH_BUTTON_DEFAULT_NONE:
+		case SMOOTH_BUTTON_DEFAULT_TRIANGLE:/* draw the triangle on button draw, not here */
+		case SMOOTH_BUTTON_DEFAULT_WIN32:/* draw background first */
+		default:
+		{
+			/*try and paint fill with parent style */
+			GtkStyle *parent_style = style;
+			GtkStateType parent_state = GTK_STATE_NORMAL;
+			
+			if ((widget) && (widget->parent)) {
+				parent_style = widget->parent->style;
+				parent_state = widget->parent->state;
+			}
+
+			smooth_fill_background(parent_style, window, parent_state, GTK_SHADOW_NONE, clip, NULL, widget, button_default, x, y, width, height, FALSE, FALSE,
+						GTK_ORIENTATION_VERTICAL,FALSE);
+		}				
+	}	
+
+	if (smooth_button_get_style(style, TRUE) == SMOOTH_BUTTON_DEFAULT_WIN32)
+	{
+		GdkGC *shade = shaded_color (style, state_type, shades[8]);
+		do_draw_shadow_with_gap(window, clip, shade, shade, button_area.x+1, button_area.y+1, button_area.width-2, button_area.height-2, 0, 0, 0, TRUE);
+		if (shade) gtk_gc_release (shade);
+	}
+}
+
+void
 smooth_draw_slider(GtkStyle * style,
      	           GdkWindow * window,
 	           GtkStateType state_type,
@@ -1410,9 +1483,26 @@
           {
             GdkRegion *cliprgn = gdk_region_polygon(fill_points, 8, GDK_EVEN_ODD_RULE);
             if (area) {
+              #ifdef GTK1
+              GdkRegion *temp = gdk_region_new();
+              GdkRegion *cliprgn2 = gdk_region_union_with_rect(temp, area);
+
+              gdk_region_destroy(temp);
+
+              temp = gdk_regions_intersect(cliprgn, cliprgn2);
+
+              gdk_region_destroy(cliprgn);
+              gdk_region_destroy(cliprgn2);
+
+              cliprgn = temp;
+//              g_warning("GTK1.2 SPECIFIC CODE STILL IN smooth_draw_extension!!!");
+              #endif
+              #ifdef GTK2
               GdkRegion *cliprgn2 = gdk_region_rectangle(area);
               gdk_region_intersect(cliprgn, cliprgn2);
               gdk_region_destroy(cliprgn2);
+//              g_warning("GTK2 SPECIFIC CODE STILL IN smooth_draw_extension!!!");
+              #endif
             }
               
             smooth_fill_background(style, window, state_type, GTK_SHADOW_NONE, NULL, cliprgn, widget, tab, x, y, width, height, FALSE, FALSE,
@@ -1615,7 +1705,7 @@
 				    0, 0, 0);
       }
     } else if (DETAIL("hruler") || DETAIL("vruler") || DETAIL("metacity") || DETAIL("bar") || DETAIL("spinbutton_up") || DETAIL("spinbutton_down") || 
-               DETAIL("optionmenu") || DETAIL("optionmenutab") || DETAIL("slider") || DETAIL("menuitem") || DETAIL("buttondefault") || 
+               DETAIL("optionmenu") || DETAIL("optionmenutab") || DETAIL("slider") || DETAIL("menuitem") || 
                DETAIL("togglebutton") || DETAIL("button") || DETAIL ("hscrollbar") || DETAIL ("vscrollbar")) 
     {
  	smooth_part_style * part = NULL;
@@ -1671,13 +1761,17 @@
           }
         else if (DETAIL("bar") && GTK_IS_PROGRESS_BAR(widget))
           {
-            part = THEME_PART(PROGRESS_PART(style));
+            part = PROGRESS_PART(style);
 
 	    x += PART_XPADDING(part);
             y += PART_YPADDING(part), 
 	    width -= PART_XPADDING(part)*2;
             height -= PART_YPADDING(part)*2; 
           } 
+        else if (DETAIL("button"))
+          {
+            part = smooth_button_part(style, FALSE);
+          }
         
         /*paint fill of orientation with a gradient, invert if GTK_SHADOW_IN */
         gradient_fill_background(style, window, state_type, area, widget, part, x, y, width, height, shadow_type == GTK_SHADOW_IN, orientation);
@@ -1692,12 +1786,11 @@
 		  y + height - ythickness(style) - 2,
 		  x + width - 19 - xthickness(style), 
                   GTK_ORIENTATION_VERTICAL);
-        else if (DETAIL("button")) 
-          {
+        else if (DETAIL("button") && (smooth_button_default_triangle(style))) {
             /* Paint a triangle here instead of in "buttondefault"
                which is drawn _behind_ the current button */
             draw_default_triangle(style, window, state_type, shadow_type, area, widget, detail, x, y, width, height);
-          }
+	}
           
         /* paint shadow */
         smooth_draw_shadow_with_gap(style, window, state_type, shadow_type, area, widget, detail, part, x, y, width, height, 0, 0, 0);     
diff -aurN Smooth/smooth_style.h gtk-smooth-engine/smooth_style.h
--- Smooth/smooth_style.h	2003-11-16 20:28:32.000000000 +0100
+++ gtk-smooth-engine/smooth_style.h	2003-12-17 00:55:25.000000000 +0100
@@ -4,6 +4,7 @@
 typedef struct _SmoothStyle SmoothStyle;
 typedef struct _SmoothStyleClass SmoothStyleClass;
 
+#if GTK2
 extern GType smooth_type_style;
 extern GtkStyleClass *style_parent_class;
 
@@ -13,20 +14,29 @@
 #define SMOOTH_IS_STYLE(object)        (G_TYPE_CHECK_INSTANCE_TYPE ((object), SMOOTH_TYPE_STYLE))
 #define SMOOTH_IS_STYLE_CLASS(klass)   (G_TYPE_CHECK_CLASS_TYPE ((klass), SMOOTH_TYPE_STYLE))
 #define SMOOTH_STYLE_GET_CLASS(obj)    (G_TYPE_INSTANCE_GET_CLASS ((obj), SMOOTH_TYPE_STYLE, SmoothStyleClass))
+#endif
 
 struct _SmoothStyle
 {
+  #if GTK2
   GtkStyle parent_instance;
+  #endif
 };
 
 struct _SmoothStyleClass
 {
+  #if GTK2
   GtkStyleClass parent_class;
+  #endif
 };
 
+#if GTK2
 void smooth_style_register_type (GTypeModule *module);
+#endif
 
+#if GTK2
 extern GMemChunk	  *	smooth_style_data_chunk;
+#endif
 
 #define FLAT_FILL_BACKGROUND(style, window, state_type, area, widget, part, x, y, width, height) (smooth_fill_background(style, window, state_type, GTK_SHADOW_NONE, area, NULL, widget, part, x, y, width, height, FALSE, FALSE, GTK_ORIENTATION_VERTICAL,FALSE))		
 #define gradient_fill_background(style, window, state_type, area, widget, part, x, y, width, height, invert, orientation) (smooth_fill_background(style, window, state_type, GTK_SHADOW_NONE, area, NULL, widget, part, x, y, width, height, TRUE, invert, orientation,FALSE))
@@ -145,6 +155,18 @@
                   gint dash_width);
 
 void
+smooth_draw_button_default(GtkStyle *style,
+                           GdkWindow *window,
+                           GtkStateType state_type,
+                           GdkRectangle *clip,
+                           GdkRectangle *button,
+                           GtkWidget *widget,
+                           gint x,
+                           gint y,
+                           gint width,
+                           gint height);
+
+void
 smooth_draw_slider(GtkStyle * style,
      	           GdkWindow * window,
 	           GtkStateType state_type,
diff -aurN Smooth/utils/draw_fill.c gtk-smooth-engine/utils/draw_fill.c
--- Smooth/utils/draw_fill.c	2003-11-16 20:28:32.000000000 +0100
+++ gtk-smooth-engine/utils/draw_fill.c	2003-12-17 00:55:25.000000000 +0100
@@ -1,137 +1,155 @@
 #include "misc_functions.h"
-
 /* the following are color routines */
 
-/* This function is taken and slightly from Wonderland, though 
+/* rgb_to_hls was taken from Wonderland, though 
  * I have seen it in other engines as well, and it apears
  * to have originated in GTK+ itself.
  */
 static void
 rgb_to_hls (gdouble *r,
-            gdouble *g,
-            gdouble *b)
+		gdouble *g,
+		gdouble *b)
 {
-  gdouble red=*r, green=*g, blue=*b;
-  gdouble h, l, s;
-  gdouble min, max, delta;
+	gdouble red=*r, green=*g, blue=*b;
+	gdouble h, l, s;
+	gdouble min, max, delta;
     
-  if (red > green)
-    {
-      max = MAX(red, blue);
-      min = MIN(green, blue);      
-    }
-  else
-    {
-      max = MAX(green, blue);
-      min = MIN(red, blue);      
-    }
-  
-  l = (max + min) / 2;
-  s = 0;
-  h = 0;
-  
-  if (max != min)
-    {
-      if (l <= 0.5)
-        s = (max - min) / (max + min);
-      else
-        s = (max - min) / (2 - max - min);
+	if (red > green)
+	{
+		max = MAX(red, blue);
+		min = MIN(green, blue);      
+	}
+	else
+	{
+		max = MAX(green, blue);
+		min = MIN(red, blue);      
+	}
+  
+	l = (max + min) / 2;
+	s = 0;
+	h = 0;
+  
+	if (max != min)
+	{
+		if (l <= 0.5)
+		{
+			s = (max - min) / (max + min);
+		}	
+		else
+		{
+			s = (max - min) / (2 - max - min);
+		}	
       
-      delta = max -min;
-      if (red == max)
-        h = (green - blue) / delta;
-      else if (green == max)
-        h = 2 + (blue - red) / delta;
-      else if (blue == max)
-        h = 4 + (red - green) / delta;
-      
-      h *= 60;
-      if (h < 0.0)
-        h += 360;
-    }
-  
-  *r = h;
-  *g = l;
-  *b = s;
+		delta = max -min;
+		if (red == max)
+		{
+			h = (green - blue) / delta;
+		}	
+		else 
+		{
+			if (green == max)
+			{
+				h = 2 + (blue - red) / delta;
+			}	
+			else
+			{ 
+				if (blue == max)
+				{
+					h = 4 + (red - green) / delta;
+				}	
+			}		
+		}
+		h *= 60;
+		if (h < 0.0)
+		{
+			h += 360;
+		}	
+	}
+  
+	*r = h;
+	*g = l;
+	*b = s;
 }
 
-/* This function is taken and slightly from Wonderland, though 
+/* hls_to_rgb was taken from Wonderland, though 
  * I have seen it in other engines as well, and it apears
  * to have originated in GTK+ itself.
  */
 static void
-hls_to_rgb (gdouble *h,
-            gdouble *l,
-            gdouble *s)
-{
-  gdouble hue = *h + 120;
-  gdouble lightness = *l;
-  gdouble saturation = *s;
-  gdouble m1, m2;
-  gdouble r, g, b;
-  
-  if (lightness <= 0.5)
-    m2 = lightness * (1 + saturation);
-  else
-    m2 = lightness + saturation - lightness * saturation;
-  m1 = 2 * lightness - m2;
-  
-  if (saturation == 0)
-    {
-      *h = lightness;
-      *l = lightness;
-      *s = lightness;
-    }
-  else
-    {
-      while (hue > 360)
-        hue -= 360;
-      while (hue < 0)
-        hue += 360;
-      
-      if (hue < 60)
-        r = m1 + (m2 - m1) * hue / 60;
-      else if (hue < 180)
-        r = m2;
-      else if (hue < 240)
-        r = m1 + (m2 - m1) * (240 - hue) / 60;
-      else
-        r = m1;
-      
-      hue = *h;
-      while (hue > 360)
-        hue -= 360;
-      while (hue < 0)
-        hue += 360;
-      
-      if (hue < 60)
-        g = m1 + (m2 - m1) * hue / 60;
-      else if (hue < 180)
-        g = m2;
-      else if (hue < 240)
-        g = m1 + (m2 - m1) * (240 - hue) / 60;
-      else
-        g = m1;
-      
-      hue = *h - 120;
-      while (hue > 360)
-        hue -= 360;
-      while (hue < 0)
-        hue += 360;
-      
-      if (hue < 60)
-        b = m1 + (m2 - m1) * hue / 60;
-      else if (hue < 180)
-        b = m2;
-      else if (hue < 240)
-        b = m1 + (m2 - m1) * (240 - hue) / 60;
-      else
-        b = m1;
+hls_to_color (gdouble hue, 
+		gdouble lightness, 
+		gdouble saturation,
+		gdouble *color)
+{
+	gdouble m1, m2;
+  
+	if (lightness <= 0.5)
+	{
+		m2 = lightness * (1 + saturation);
+	}	
+	else
+	{
+		m2 = lightness + saturation - lightness * saturation;
+	}	
+	m1 = 2 * lightness - m2;
+
+	if (hue > 360)
+	{
+		hue = (((long int)hue % 360) + (hue - (long int)hue));
+	}
+	else
+	{
+		if (hue < 0)
+		{
+			hue = (360 - (ABS((long int)hue) % 360) + (hue - (long int)hue));
+		}
+	}
+
+	if (hue < 60)
+	{
+		*color = m1 + (m2 - m1) * hue / 60;
+	}
+	else 
+	{
+		if (hue < 180)
+		{
+			*color = m2;
+		}	
+		else 
+		{
+			if (hue < 240)
+			{
+				*color = m1 + (m2 - m1) * (240 - hue) / 60;
+			}	
+			else
+			{
+				*color = m1;
+			}
+		}
+	}
+}
+
+static void
+hls_to_rgb (gdouble *h, gdouble *l, gdouble *s)
+{
+	gdouble lightness = *l, saturation = *s;
+	gdouble r=lightness, g=lightness, b=lightness;
+  
+	if (saturation != 0)
+	{
+		/* red is extracted from the range hue+120 */
+		hls_to_color(*h + 120, lightness, saturation, &r);
+	
+		/* green is extracted from the range hue */
+		hls_to_color(*h, lightness, saturation, &g);
       
-      *h = r;
-      *l = g;
-      *s = b;
-    }
+		/* blue is extracted from the range hue - 120*/
+		hls_to_color(*h - 120, lightness, saturation, &b);     
+	}
+
+	*h = r;
+	*l = g;
+	*s = b;
 }
 
 /* This function is taken and slightly from Wonderland, though 
@@ -141,52 +159,59 @@
 void
 shade (GdkColor * a, GdkColor * b, gdouble k)
 {
-  gdouble red = (gdouble) a->red / 65535.0;
-  gdouble green = (gdouble) a->green / 65535.0;
-  gdouble blue = (gdouble) a->blue / 65535.0;
+	gdouble red = (gdouble) a->red / 65535.0;
+	gdouble green = (gdouble) a->green / 65535.0;
+	gdouble blue = (gdouble) a->blue / 65535.0;
   
-  rgb_to_hls (&red, &green, &blue);
+	rgb_to_hls (&red, &green, &blue);
   
-  green = MIN(green*k, 1.0);
-  green = MAX(green, 0.0);
+	green = MIN(green*k, 1.0);
+	green = MAX(green, 0.0);
   
-  blue = MIN(blue*k, 1.0);
-  blue = MAX(blue, 0.0);
+	blue = MIN(blue*k, 1.0);
+	blue = MAX(blue, 0.0);
   
-  hls_to_rgb (&red, &green, &blue);
+	hls_to_rgb (&red, &green, &blue);
   
-  b->red = red * 65535.0;
-  b->green = green * 65535.0;
-  b->blue = blue * 65535.0;
+	b->red = red * 65535.0;
+	b->green = green * 65535.0;
+	b->blue = blue * 65535.0;
 }
 
 void 
 alloc_gradient_color(GdkColor * color,
-                     GdkColormap * colormap,
-                     GdkColor light, 
-                     GdkColor dark,
-                     gint position,
-                     gint steps,
-                     gboolean quadratic)
-{
-  gfloat a, b, c, delta;
-  if (quadratic) {
-    
-    /* delta = ax³ + bx² + cx */ 
+			GdkColormap * colormap,
+			GdkColor light, 
+			GdkColor dark,
+			gint position,
+			gint steps,
+			gboolean quadratic)
+{
+	gfloat delta;
+
+	if (quadratic) 
+	{
+		gfloat a, b, c;
+
+		a = 4.0 / (steps * steps * steps);
+		b = -6.0 / (steps * steps);
+		c = 3.0 / steps;
    
-    a = 4.0 / (steps * steps * steps);
-    b = -6.0 / (steps * steps);
-    c = 3.0 / steps;
-   
-    delta = (a * pow(position, 3)) + (b * pow(position, 2)) + (c * position);
-  } else {
-    /* delta = i/steps */     
-    delta = ((float)position/(float)steps);
-  }
-  color->red = light.red + (float)((dark.red - light.red))*delta;
-  color->green = light.green + (float)((dark.green - light.green))*delta;
-  color->blue = light.blue + (float)((dark.blue - light.blue))*delta;
-  gdk_colormap_alloc_color(colormap, color, FALSE, TRUE);
+		/* delta = ax³ + bx² + cx */ 
+		delta = (a * pow(position, 3)) + (b * pow(position, 2)) + (c * position);
+	} 
+	else 
+	{
+		/* delta = i/steps */     
+
+		delta = ((float)position/(float)steps);
+	}
+
+	color->red = light.red + (float)((dark.red - light.red))*delta;
+	color->green = light.green + (float)((dark.green - light.green))*delta;
+	color->blue = light.blue + (float)((dark.blue - light.blue))*delta;
+
+	gdk_colormap_alloc_color(colormap, color, FALSE, TRUE);
 }
 
 /* the following are gradient fill routines */
@@ -224,351 +249,412 @@
 
 void
 gdk_draw_gradient (GdkWindow * window,
-                   GdkGC * gc,
-                   GdkColormap * colormap,
-                   GdkRectangle * area,
-                   gint x,
-                   gint y,
-                   gint width,
-                   gint height,
-                   GdkColor light, 
-                   GdkColor dark, 
-                   GdkGradientType gradient_type,
-                   gboolean quadratic,
-		   gboolean noclip)
-{
-  GdkRectangle clip;
-  GdkColor color;
-  gint i, steps=0;
-  gboolean horizontal = (gradient_type == GDK_GRADIENT_HORIZONTAL);
-  gboolean northern   = (gradient_type == GDK_GRADIENT_NORTHERN_DIAGONAL);
-  gboolean diagonal   = ((gradient_type == GDK_GRADIENT_NORTHERN_DIAGONAL) || (gradient_type == GDK_GRADIENT_SOUTHERN_DIAGONAL));
-
-  clip.x = x;
-  clip.y = y;
-  clip.width = width;
-  clip.height = height;
-
-  g_return_if_fail(window != NULL);
-  g_return_if_fail(colormap != NULL);
-  g_return_if_fail(gc != NULL);
-    
-  if (diagonal)
-    steps = width + height - 1;
-  else if (horizontal)
-    steps = width; 
-  else
-    steps = height;
-
-  if (!noclip) {
-    if (area) {
-      GdkRectangle clip2;       
-      if (gdk_rectangle_intersect(area,&clip, &clip2))
-        gdk_gc_set_clip_rectangle(gc, &clip2);
-      else
-        gdk_gc_set_clip_rectangle(gc, area);
-    } else
-      gdk_gc_set_clip_rectangle(gc, &clip);
-  }
+			GdkGC * gc,
+			GdkColormap * colormap,
+			GdkRectangle * area,
+			gint x,
+			gint y,
+			gint width,
+			gint height,
+			GdkColor light, 
+			GdkColor dark, 
+			GdkGradientType gradient_type,
+			gboolean quadratic,
+			gboolean noclip)
+{
+	gboolean horizontal = (gradient_type == GDK_GRADIENT_HORIZONTAL);
+	gboolean northern   = (gradient_type == GDK_GRADIENT_NORTHERN_DIAGONAL);
+	gboolean diagonal   = ((gradient_type == GDK_GRADIENT_NORTHERN_DIAGONAL) || (gradient_type == GDK_GRADIENT_SOUTHERN_DIAGONAL));
+
+	GdkRectangle clip;
+	GdkColor color;
+	gint i, steps=0;
+
+	g_return_if_fail(window != NULL);
+	g_return_if_fail(colormap != NULL);
+	g_return_if_fail(gc != NULL);
+
+	clip.x = x;
+	clip.y = y;
+	clip.width = width;
+	clip.height = height;
    
-  for(i=0; i < steps; i++) {
-    alloc_gradient_color(&color, colormap, light, dark, i, steps, quadratic);
-    gdk_gc_set_foreground(gc, &color);
-    if (diagonal) {
-      if (northern)
-        gdk_draw_line (window, gc, x + i, y, x, y + i);
-      else
-        gdk_draw_line (window, gc, x + width - 1 - i, y, x + width - 1, y + i);         
-    } else {
-      if (horizontal)
-        gdk_draw_line(window, gc, x+i, y, x+i, y+height);
-      else
-        gdk_draw_line(window, gc, x, y+i, x+width, y+i);
-    }
-    gdk_colormap_free_colors(colormap, &color, 1);
-  }
-
-  if (!noclip)
-    gdk_gc_set_clip_rectangle(gc, NULL); 
+	if (diagonal)
+	{
+		steps = width + height - 1;
+	}	
+	else 
+	{
+		if (horizontal)
+		{
+			steps = width; 
+		}	
+		else
+		{
+			steps = height;
+		}
+	}	
+
+	if (!noclip) 
+	{
+		if (area) 
+		{
+			GdkRectangle clip2;       
+
+			if (gdk_rectangle_intersect(area,&clip, &clip2))
+			{
+				gdk_gc_set_clip_rectangle(gc, &clip2);
+			}	
+			else
+			{
+				gdk_gc_set_clip_rectangle(gc, area);
+			}	
+		} 
+		else
+		{
+			gdk_gc_set_clip_rectangle(gc, &clip);
+		}	
+	}
+   
+	for(i=0; i < steps; i++) 
+	{
+		alloc_gradient_color(&color, colormap, light, dark, i, steps, quadratic);
+		gdk_gc_set_foreground(gc, &color);
+		if (diagonal) 
+		{
+			if (northern)
+			{
+				gdk_draw_line (window, gc, x + i, y, x, y + i);
+			}	
+			else
+			{
+				gdk_draw_line (window, gc, x + width - 1 - i, y, x + width - 1, y + i);         
+			}	
+		} 
+		else 
+		{
+			if (horizontal)
+			{
+				gdk_draw_line(window, gc, x+i, y, x+i, y+height);
+			}	
+			else
+			{
+				gdk_draw_line(window, gc, x, y+i, x+width, y+i);
+			}	
+		}
+
+		gdk_colormap_free_colors(colormap, &color, 1);
+	}
+
+	if (!noclip)
+	{
+		gdk_gc_set_clip_rectangle(gc, NULL); 
+	}	
 }
 
 void
 gdk_draw_shaded_gradient (GdkWindow * window,
-                          GdkGC * gc,
-                          GdkColormap * colormap,
-                          GdkRectangle * area,
-                          gint x,
-                          gint y,
-                          gint width,
-                          gint height,
-                          GdkColor color, 
-                          gfloat shade_value, 
-                          gfloat shine_value, 
-                          GdkGradientType gradient_type,
-                          gboolean quadratic,
-			  gboolean noclip)
+				GdkGC * gc,
+				GdkColormap * colormap,
+				GdkRectangle * area,
+				gint x,
+				gint y,
+				gint width,
+				gint height,
+				GdkColor color, 
+				gfloat shade_value, 
+				gfloat shine_value, 
+				GdkGradientType gradient_type,
+				gboolean quadratic,
+				gboolean noclip)
 {
-  GdkColor light, dark;
+	GdkColor light, dark;
   
-  shade (&color, &dark, shade_value);
-  shade (&color, &light, shine_value);
+	shade (&color, &dark, shade_value);
+	shade (&color, &light, shine_value);
 
-  gdk_draw_gradient(window, gc, colormap, area, x, y, width, height, light, dark, gradient_type, quadratic, noclip);
+	gdk_draw_gradient(window, gc, colormap, area, x, y, width, height, light, dark, gradient_type, quadratic, noclip);
 }
 
 /* the following are pixbuf fill routines */
 static GHashTable* pixbuf_cache = NULL;
 
 typedef struct
-  {
-    gchar       *file_name;
-    GdkPixbuf   *pixbuf;
-    gint 	ref_count;
-  } GdkCachedPixbuf;
+{
+	gchar		*file_name;
+	GdkPixbuf	*pixbuf;
+	gint		ref_count;
+} GdkCachedPixbuf;
 
 static void
 free_cache(GdkCachedPixbuf *cache)
 {
-  gdk_pixbuf_unref(cache->pixbuf);
-  g_free(cache->file_name);
-  g_free(cache);
+	gdk_pixbuf_unref(cache->pixbuf);
+	g_free(cache->file_name);
+	g_free(cache);
 }
 
 static GdkCachedPixbuf *
 new_cache(gchar * file_name)
 {
-   GdkCachedPixbuf *result=NULL;
+	GdkCachedPixbuf *result=NULL;
 
-   result = g_new0(GdkCachedPixbuf, 1);
-   result->ref_count = 1;
-   result->file_name = g_strdup(file_name);
+	result = g_new0(GdkCachedPixbuf, 1);
+	result->ref_count = 1;
+	result->file_name = g_strdup(file_name);
    
-   result->pixbuf = gdk_pixbuf_new_from_file(file_name, NULL);
+#if GTK1
+	result->pixbuf = gdk_pixbuf_new_from_file(file_name);
+#endif
+
+#if GTK2
+	result->pixbuf = gdk_pixbuf_new_from_file(file_name, NULL);
+#endif
 
-   return result;
+	return result;
 }
 
 static gboolean 
 force_cleanup_cache(gpointer key, gpointer value, gpointer user_data)
 {
-  if (value) 
-    free_cache((GdkCachedPixbuf *)value);
-  return TRUE;
+	if (value) 
+	{
+		free_cache((GdkCachedPixbuf *)value);
+	}	
+	return TRUE;
 }
 
 void
 cleanup_gdk_pixbuf_cache(gboolean force)
 {
-   if (pixbuf_cache) {
-     if (force)
-       g_hash_table_foreach_remove(pixbuf_cache, force_cleanup_cache, NULL);
-
-     if (g_hash_table_size(pixbuf_cache)<=0) {
-       g_hash_table_destroy(pixbuf_cache);
-       pixbuf_cache = NULL;
-     }  
-   }   
+	if (pixbuf_cache) 
+	{
+		if (force)
+		{
+			g_hash_table_foreach_remove(pixbuf_cache, force_cleanup_cache, NULL);
+		}
+		
+		if (g_hash_table_size(pixbuf_cache)<=0) 
+		{
+			g_hash_table_destroy(pixbuf_cache);
+			pixbuf_cache = NULL;
+		}  
+	}   
 }
 
 static GdkPixbuf *
 internal_gdk_pixbuf_get_by_name(gchar * file_name)
 {
-   GdkCachedPixbuf *cache=NULL;
-   GdkPixbuf *result=NULL;
+	GdkCachedPixbuf *cache=NULL;
+	GdkPixbuf *result=NULL;
    
-   if (!pixbuf_cache)
-     pixbuf_cache=g_hash_table_new(g_str_hash, g_str_equal);
-
-   cache = g_hash_table_lookup(pixbuf_cache, file_name);
+	if (!pixbuf_cache)
+	{
+		pixbuf_cache=g_hash_table_new(g_str_hash, g_str_equal);
+	}
+	
+	cache = g_hash_table_lookup(pixbuf_cache, file_name);
    
-   if (!cache) {
-     cache = new_cache(file_name);
-     if (cache) 
-       g_hash_table_insert(pixbuf_cache, cache->file_name, cache);
-   }
-  
-   if (cache) {
-     result = cache->pixbuf;
-     cache->ref_count++;
-   }
+	if (!cache) 
+	{
+		cache = new_cache(file_name);
+
+		if (cache) 
+			g_hash_table_insert(pixbuf_cache, cache->file_name, cache);
+	}
+  
+	if (cache) 
+	{
+		result = cache->pixbuf;
+		cache->ref_count++;
+	}
    
-   return result;
+	return result;
 }
 
 static void
 internal_gdk_pixbuf_unref(gchar * file_name)
 {  
-   GdkCachedPixbuf *cache=NULL;
-   if (pixbuf_cache) {
-     cache = g_hash_table_lookup(pixbuf_cache, file_name);
+	GdkCachedPixbuf *cache = NULL;
 
-     if (cache) {
-       cache->ref_count--;
+	if (pixbuf_cache) {
+		cache = g_hash_table_lookup(pixbuf_cache, file_name);
+
+		if (cache) {
+			cache->ref_count--;
    
-       if (cache->ref_count == 0) {
-         g_hash_table_remove(pixbuf_cache, file_name);
-         free_cache(cache);
-       }   
-     }
-     cleanup_gdk_pixbuf_cache(FALSE);  
-  }   
+			if (cache->ref_count == 0) {
+				g_hash_table_remove(pixbuf_cache, file_name);
+				free_cache(cache);
+			}   
+		}
+		cleanup_gdk_pixbuf_cache(FALSE);  
+	}   
 }
 
 static void
 internal_tile_pixbuf(GdkWindow * window,
-                     GdkGC * gc,
-                     GdkPixbuf *pixbuf,
-   	             GdkRectangle * area,
-                     int xoffset, 
-                     int yoffset,
- 		     int x,
- 		     int y,
- 		     int width,
- 		     int height)
-{
-  GdkRectangle target;
-  GdkPoint min_point;
-  GdkPoint max_point;
-  int num_left;
-  int num_above;
-
-  int tile_x;
-  int tile_y;
-  int tile_width;
-  int tile_height;
+			GdkGC * gc,
+			GdkPixbuf *pixbuf,
+			GdkRectangle * area,
+			int xoffset, 
+			int yoffset,
+			int x,
+			int y,
+			int width,
+			int height)
+{
+	GdkRectangle target;
+	GdkPoint min_point;
+	GdkPoint max_point;
+	int num_left;
+	int num_above;
+
+	int tile_x;
+	int tile_y;
+	int tile_width;
+	int tile_height;
 
-  tile_width=gdk_pixbuf_get_width(pixbuf);
-  tile_height=gdk_pixbuf_get_height(pixbuf);
+	tile_width=gdk_pixbuf_get_width(pixbuf);
+	tile_height=gdk_pixbuf_get_height(pixbuf);
 
-  if (area) {
-      GdkRectangle tmp;       
+	if (area) {
+		GdkRectangle tmp;       
       
-      tmp.x = x+xoffset;
-      tmp.y = y+yoffset;
-      tmp.width = width;
-      tmp.height = height;
+		tmp.x = x+xoffset;
+		tmp.y = y+yoffset;
+		tmp.width = width;
+		tmp.height = height;
 
-      gdk_rectangle_intersect(area, &tmp, &target);
+		gdk_rectangle_intersect(area, &tmp, &target);
       
-      if ((target.width <= 0) && (target.height <= 0))
-        return;
-  } else {
-      target.x = x+xoffset;
-      target.y = y+yoffset;
-      target.width = width;
-      target.height = height;
-  }
-
-  /* The number of tiles left and above the target area */
-  num_left = target.x / tile_width;
-  num_above = target.y / tile_height;
+		if ((target.width <= 0) && (target.height <= 0))
+			return;
+	} else {
+		target.x = x+xoffset;
+		target.y = y+yoffset;
+		target.width = width;
+		target.height = height;
+  	}
+
+	/* The number of tiles left and above the target area */
+	num_left = target.x / tile_width;
+	num_above = target.y / tile_height;
   
-  min_point.x = target.x + (num_left * tile_width) - tile_width;
-  min_point.y = target.x + (num_above * tile_height) - tile_height;
+	min_point.x = target.x + (num_left * tile_width) - tile_width;
+	min_point.y = target.x + (num_above * tile_height) - tile_height;
               	
-  max_point.x = (target.x + target.width + 2 * tile_width);
-  max_point.y = (target.y + target.height + 2 * tile_height);
+	max_point.x = (target.x + target.width + 2 * tile_width);
+	max_point.y = (target.y + target.height + 2 * tile_height);
 
-  for (tile_y = min_point.y; tile_y <= max_point.y; tile_y += tile_height) {
-     for (tile_x = min_point.x; tile_x <= max_point.x; tile_x += tile_width) {
-        GdkRectangle current;
-        GdkRectangle tmp;
-
-        current.x = tile_x;
-        current.y = tile_y;
-        current.width = tile_width;
-        current.height = tile_height;
+	for (tile_y = min_point.y; tile_y <= max_point.y; tile_y += tile_height) {
+		for (tile_x = min_point.x; tile_x <= max_point.x; tile_x += tile_width) {
+			GdkRectangle current;
+			GdkRectangle tmp;
+
+			current.x = tile_x;
+			current.y = tile_y;
+			current.width = tile_width;
+			current.height = tile_height;
 
-        gdk_rectangle_intersect(&target, &current, &tmp);
+			gdk_rectangle_intersect(&target, &current, &tmp);
         
-        if ((tmp.width > 0) && (tmp.height > 0)) 
-          {
-            gdk_pixbuf_render_to_drawable (pixbuf, window, gc,
-	  			           0, 0, 
-				           tmp.x, tmp.y,
-				           tile_width, tile_height,
-				           GDK_RGB_DITHER_NONE,
-				           0, 0);
-
-          }				           
-     }
-  }
+			if ((tmp.width > 0) && (tmp.height > 0)) 
+			{
+				gdk_pixbuf_render_to_drawable (pixbuf, window, gc,
+								0, 0, 
+								tmp.x, tmp.y,
+								tile_width, tile_height,
+								GDK_RGB_DITHER_NONE,
+								0, 0);
+
+			} 
+		}
+	}
 }
 
 void
 gdk_tile_pixbuf_fill (GdkWindow * window,
-                      GdkGC * gc,
-		      gchar * file_name,
-		      GdkRectangle * area,
-		      gint xoffset, 
-		      gint yoffset,
-		      gint x,
-		      gint y,
-		      gint width,
-		      gint height,
-		      gboolean noclip, 
-                      gboolean window_is_buffered)
-{
-  GdkRectangle clip;
-  GdkPixbuf *pixbuf = NULL;
-  GdkPixmap *tmp_pixmap = NULL;
-  GdkGC *tmp_gc;
-  gint pixbuf_width=-1, pixbuf_height=-1;
-  
-  pixbuf = internal_gdk_pixbuf_get_by_name(file_name);
-
-  if (!pixbuf)
-    return;
-    
-  pixbuf_width=gdk_pixbuf_get_width(pixbuf);
-  pixbuf_height=gdk_pixbuf_get_height(pixbuf);
-
-  clip.x = x+xoffset;
-  clip.y = y+yoffset;
-  clip.width = width;
-  clip.height = height;
-
-  if (!noclip) {
-    if (area) {
-      GdkRectangle clip2;       
-      if (gdk_rectangle_intersect(area,&clip, &clip2))
-        gdk_gc_set_clip_rectangle(gc, &clip2);
-      else
-        gdk_gc_set_clip_rectangle(gc, area);
-    } else
-      gdk_gc_set_clip_rectangle(gc, &clip);
-  }
-
-  if (window_is_buffered)
-    internal_tile_pixbuf(window, gc, pixbuf, &clip, xoffset, yoffset, x, y, width, height);
-  else {
-    tmp_pixmap = gdk_pixmap_new (window,
-	  		         pixbuf_width,
-			         pixbuf_height,
-			         gdk_rgb_get_visual()->depth);
-
-    tmp_gc = gdk_gc_new (tmp_pixmap);
-    gdk_pixbuf_render_to_drawable (pixbuf, tmp_pixmap, tmp_gc,
-  				   0, 0, 
-				   0, 0,
-				   pixbuf_width, pixbuf_height,
-				   GDK_RGB_DITHER_NORMAL,
-				   0, 0);
-    gdk_gc_unref (tmp_gc);
-
-    gdk_gc_set_fill(gc, GDK_TILED);
-    gdk_gc_set_tile(gc,tmp_pixmap);
-    gdk_gc_set_ts_origin(gc, 0, 0);
-    gdk_draw_rectangle (window, gc, TRUE, x, y, width, height);
-
-    gdk_gc_set_fill(gc, GDK_SOLID);
-    gdk_pixmap_unref (tmp_pixmap);
-  }
+			GdkGC * gc,
+			gchar * file_name,
+			GdkRectangle * area,
+			gint xoffset, 
+			gint yoffset,
+			gint x,
+			gint y,
+			gint width,
+			gint height,
+			gboolean noclip, 
+			gboolean window_is_buffered)
+{
+	GdkRectangle clip;
+	GdkPixbuf *pixbuf = NULL;
+	GdkPixmap *tmp_pixmap = NULL;
+	GdkGC *tmp_gc;
+	gint pixbuf_width=-1, pixbuf_height=-1;
+  
+	pixbuf = internal_gdk_pixbuf_get_by_name(file_name);
+
+	if (!pixbuf)
+	{
+		return;
+    	}
+    	
+	pixbuf_width=gdk_pixbuf_get_width(pixbuf);
+	pixbuf_height=gdk_pixbuf_get_height(pixbuf);
+
+	clip.x = x+xoffset;
+	clip.y = y+yoffset;
+	clip.width = width;
+	clip.height = height;
+
+	if (!noclip) 
+	{
+		if (area) 
+		{
+			GdkRectangle clip2;       
+
+			if (gdk_rectangle_intersect(area,&clip, &clip2))
+				gdk_gc_set_clip_rectangle(gc, &clip2);
+			else
+				gdk_gc_set_clip_rectangle(gc, area);
+		} 
+		else
+		{
+			gdk_gc_set_clip_rectangle(gc, &clip);
+		}	
+	}
+
+	if (window_is_buffered)
+		internal_tile_pixbuf(window, gc, pixbuf, &clip, xoffset, yoffset, x, y, width, height);
+	else {
+		tmp_pixmap = gdk_pixmap_new (window,
+						pixbuf_width,
+						pixbuf_height,
+						gdk_rgb_get_visual()->depth);
+
+		tmp_gc = gdk_gc_new (tmp_pixmap);
+		gdk_pixbuf_render_to_drawable (pixbuf, tmp_pixmap, tmp_gc,
+						0, 0, 
+						0, 0,
+						pixbuf_width, pixbuf_height,
+						GDK_RGB_DITHER_NORMAL,
+						0, 0);
+		gdk_gc_unref (tmp_gc);
+
+		gdk_gc_set_fill(gc, GDK_TILED);
+		gdk_gc_set_tile(gc,tmp_pixmap);
+		gdk_gc_set_ts_origin(gc, 0, 0);
+		gdk_draw_rectangle (window, gc, TRUE, x, y, width, height);
+
+		gdk_gc_set_fill(gc, GDK_SOLID);
+		gdk_pixmap_unref (tmp_pixmap);
+	}
   
-  internal_gdk_pixbuf_unref (file_name);
+	internal_gdk_pixbuf_unref (file_name);
 
-  if (!noclip)
-    gdk_gc_set_clip_rectangle(gc, NULL); 
+	if (!noclip)
+		gdk_gc_set_clip_rectangle(gc, NULL); 
 
-  return;
+	return;
 }
diff -aurN Smooth/utils/misc_functions.c gtk-smooth-engine/utils/misc_functions.c
--- Smooth/utils/misc_functions.c	2003-11-16 20:28:32.000000000 +0100
+++ gtk-smooth-engine/utils/misc_functions.c	2003-10-29 17:52:19.000000000 +0100
@@ -374,6 +374,7 @@
 			      gint         *width,
 			      gint         *height)
 {
+#if GTK2
   gint slider_width = 15, stepper_size = 15;
   gint box_width;
   gint box_height;
@@ -401,6 +402,14 @@
   *y = (*y - (box_height - *height) / 2) + 2;
   *width = box_width - 3;
   *height = box_height - 3;
+#endif
+
+#if GTK1
+  *x += 2;
+  *y += 2;
+  *width -= 4;
+  *height -= 4;
+#endif
 }
 
 /* This function is based on reverse_engineer_stepper_box
@@ -418,6 +427,7 @@
 			      gint         *width,
 			      gint         *height)
 {
+#ifdef GTK2
   gint size = pango_font_description_get_size (widget->style->font_desc);
   gint realheight, realwidth;
 
@@ -435,6 +445,7 @@
   *y += ((*height - realheight) / 2) + (arrow_type==GTK_ARROW_DOWN?1:-1);
   *width = realwidth;
   *height = realheight;
+#endif
 }
 
 /* This function is a home-grown (probably flawed) function 
@@ -458,6 +469,7 @@
       reverse_engineer_spin_button (widget, arrow_type,
 				    x, y, width, height);
    }
+  #if GTK2
   else if (DETAIL("menuitem"))
     {
       *width += 2;
@@ -470,6 +482,19 @@
       *x -= 1;
       *y -= 1;
   }  
+  #endif  
+  #if GTK1
+  else if (DETAIL("menuitem"))
+    {
+      *width += 2;
+      *height += 2;
+      *x -= 1;
+      *y += 0;
+    }
+  else if (DETAIL("arrow")) {
+      *y += 1;
+  }  
+  #endif  
 }
 
 /* This function is based on a portion of Xenophilia's xeno_draw_extension */
diff -aurN Smooth/utils/misc_functions.h gtk-smooth-engine/utils/misc_functions.h
--- Smooth/utils/misc_functions.h	2003-11-16 20:28:32.000000000 +0100
+++ gtk-smooth-engine/utils/misc_functions.h	2003-12-19 22:22:14.000000000 +0100
@@ -15,8 +15,15 @@
 #define DETAIL(xx) ((detail) && (!strcmp(xx, detail)))
 #define FUZZY_COMPARE(i, j, fudge) ((i>j)?(i - j <= fudge):(j - i <= fudge))
 
+#if GTK_CHECK_VERSION(2, 0, 0)
+#define GTK2		1
+#else
+#define GTK1		1 
+#endif
+
 #define IS_HANDLE_BOX_ITEM(object) ((widget) && (widget->parent) && GTK_IS_HANDLE_BOX(gtk_widget_get_parent (widget)))
 
+#ifdef GTK2
 #define xthickness(style) (((GtkStyle *)style)->xthickness)
 #define ythickness(style) (((GtkStyle *)style)->ythickness)
 
@@ -30,12 +37,40 @@
 
 #define gtk_type_is_a(object, type) (g_type_is_a(object, type))
 
+/* COMBO is deprecated in favour of COMBO_BOX, and thus doesn't exist in >=2.3,
+   since this is the future we wrap GTK_IS_COMBO_BOX around GTK_IS_COMBO for 
+   earlier versions of GTK2.
+*/
+#ifndef GTK_IS_COMBO_BOX
+#define GTK_IS_COMBO_BOX(obj) GTK_IS_COMBO(obj)
+#endif
+
 typedef const gchar		detail_char;
 
 static GtkStyleClass *parent_class = NULL;
 
 #define IS_BONOBO_DOCK_ITEM(object) ((widget) && (widget->parent) && (GTK_IS_HANDLE_BOX(gtk_widget_get_parent (widget)) || (g_type_name(G_OBJECT_TYPE(widget->parent))) && (!strcmp("BonoboDockItem", g_type_name(G_OBJECT_TYPE(widget->parent))))))
 
+#endif
+
+#ifdef GTK1
+#define gtk_range_get_value(range) gtk_range_get_adjustment(range)->value
+#define gtk_range_get_inverted(range) FALSE
+
+#define gtk_widget_get_parent(widget) (((widget) && (widget->parent))?widget->parent:NULL)
+
+#define xthickness(style) (((GtkStyle *)style)->klass->xthickness)
+#define ythickness(style) (((GtkStyle *)style)->klass->ythickness)
+#define g_ascii_strncasecmp(str1, str2, len) (g_strncasecmp(str1, str2, len))
+
+typedef gchar			detail_char;
+
+extern GtkStyleClass smooth_default_class;
+
+#define IS_BONOBO_DOCK_ITEM(object) (IS_HANDLE_BOX_ITEM(object))
+
+#endif
+
 #define NO_CHECK	1
 #define FAST_CHECK	2
 #define SLOPPY_CHECK	3
